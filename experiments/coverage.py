import json
import matplotlib.pyplot as plt
from matplotlib_venn import venn2
import glob
import numpy as np
import subprocess
import os
from collections import defaultdict, namedtuple
import sys
import time
import colorama
from colorama import Fore, Back, Style
import random
import subprocess
from multiprocessing import Pool, cpu_count
from concurrent.futures import ProcessPoolExecutor, as_completed, ThreadPoolExecutor
import argparse
import asyncio
import pandas as pd
from matplotlib.dates import DateFormatter, MinuteLocator
from compile import solidity_compilation_flags

def int_to_string_array(int_array):
  string_array = [str(num) for num in int_array]
  return string_array

# Extract edge coverages from llvm-cov JSON file
def extract_collected_edges(coverage_data) -> dict :
  position = namedtuple('Position', ['function_name', 'line_start', 'column_start', 'line_end', 'column_end'])
  collected_edges = defaultdict(int)
  # Iterate through the functions in the coverage data
  for function in coverage_data['data'][0]['functions']:
    function_name = function['name']
    # Check if the function has collected edges
    if 'branches' in function:
      for branch in function['branches']:
        # https://github.com/llvm/llvm-project/blob/34f8573a514915222630cf21e8a0c901a25f4ca0/llvm/tools/llvm-cov/CoverageExporterJson.cpp#L96
        collected_edges[position(function_name, branch[0],branch[1],branch[2],branch[3])] = branch[4]
  return collected_edges

solidity_sources = []
def collect_solidity_sources(root_dir):
  for dirpath, _, filenames in os.walk(root_dir):
    for filename in filenames:
      if filename.endswith('.cpp') and 'deps' not in dirpath and 'build' not in dirpath:
        solidity_sources.append(filename)
      elif filename.endswith('.h') and 'deps' not in dirpath and 'build' not in dirpath:
        solidity_sources.append(filename)

# Define a named tuple for filename and line number
FilenameLine = namedtuple('FilenameLine', ['filename', 'linenum'])

def process_gcov_file(gcov_file):
  collected_lines = set()
  lines = set()

  with open(gcov_file, 'r') as f:
    stmtlines = f.readlines()

  for line in stmtlines:
    if line == '------------------\n':
      continue
    
    parts = line.strip().split(':')
    if len(parts) < 2:
      continue

    covcnt = parts[0].strip()
    linenum = parts[1].strip()

    if covcnt != '-' and covcnt != '#####':
      collected_lines.add(FilenameLine(filename=os.path.basename(gcov_file), linenum=linenum))
      lines.add(FilenameLine(filename=os.path.basename(gcov_file), linenum=linenum))
    elif covcnt == '#####':
      lines.add(FilenameLine(filename=os.path.basename(gcov_file), linenum=linenum))

  return collected_lines, lines

def process_gcov_files(gcov_files):
  total_collected_lines = set()
  total_lines = set()

  for gcov_file in gcov_files:
    collected_lines, lines = process_gcov_file(gcov_file)
    total_collected_lines.update(collected_lines)
    total_lines.update(lines)

  return total_collected_lines, total_lines

# Extract line coverages from gcov files generated by gcov
def extract_collected_lines(gcov_folder_path) -> set :
  start = time.time()
  generate_gcov_files(gcov_folder_path)
  end = time.time()
  print(Fore.MAGENTA + f"generate_gcov_files: {end-start} seconds")
  # find all gcov files
  gcov_files = []
  for root, dirs, files in os.walk(gcov_folder_path):
    for file in files:
      if file.endswith('.gcov') and file.split('.gcov')[0] in solidity_sources:
        gcov_files.append(os.path.join(root, file))
  print(Fore.RESET + f"Found {len(gcov_files)} .gcov files")
  start = time.time()
  res = process_gcov_files(gcov_files)
  end = time.time()
  print(Fore.MAGENTA + f"process_gcov_files: {end-start} seconds")
  return res

def remove_gcov_files(gcov_folder_path):
  cur_path = os.getcwd()
  os.chdir(gcov_folder_path)
  command = 'find . -name "*.gcov" -exec rm -rf {} +;'
  try:
    subprocess.run(command, shell=True)
  except Exception as e:
    print(f"Error: {e}")
  os.chdir(cur_path)

def remove_gcda_files(gcda_folder_path):
  cur_path = os.getcwd()
  os.chdir(gcda_folder_path)
  command = 'find . -name "*.gcda" -exec rm -rf {} +;'
  try:
    subprocess.run(command, shell=True)
  except Exception as e:
    print(f"Error: {e}")
  os.chdir(cur_path)
 
def find_gcda_files(directory):
  """Find all .gcda files in the given directory and its subdirectories."""
  gcda_files = []
  for root, _, files in os.walk(directory):
      gcda_files.extend(os.path.join(root, file) for file in files if file.endswith('.gcda'))
  return gcda_files

def generate_gcov_files(gcda_folder_path) :
  remove_gcov_files(gcda_folder_path)
  # linux command of finding all gcda files in the folder and using gcov to generate gcov files
  cur_path = os.getcwd()
  os.chdir(gcda_folder_path)
  # if this OS is linux
  if sys.platform == 'linux':
    command = 'find . -name "*.gcda" -exec gcov {} +;'
  elif sys.platform == 'darwin':  
    command = 'find . -name "*.gcda" -exec llvm-cov gcov {} +;'
  else:
    print("Unsupported OS: ", sys.platform)
    return
  try:
    subprocess.run(command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
  except Exception as e:
    print(f"Error: {e}")
  os.chdir(cur_path)

def run_gcov(file):
  """Run gcov on a single file."""
  if sys.platform == 'linux':
    command = 'gcov'
  elif sys.platform == 'darwin':  
    command = 'llvm-cov gcov'
  else:
    print("Unsupported OS: ", sys.platform)
    return
  try:
    result = subprocess.run(f'{command} {file}', shell=True, capture_output=True, text=True, check=True)
    return (file, result.stdout)
  except subprocess.CalledProcessError as e:
    return (file, f"Error processing {file}: {e.stderr}")

def generate_gcov_files_in_parallel(gcda_directory, max_workers=None):
  """Run gcov on all .gcda files in parallel."""
  start = time.time()
  gcda_files = find_gcda_files(gcda_directory)
  end = time.time()
  print(Fore.MAGENTA + f"find_gcda_files: {end-start} seconds")
  if not max_workers:
    max_workers = cpu_count()
  print(Fore.RESET + f"Found {len(gcda_files)} .gcda files. Processing with {max_workers} workers.")
  # with Pool(processes=max_workers) as pool:
  #   pool.starmap(run_gcov, [(file, gcda_directory) for file in gcda_files])
  cur_dir = os.getcwd()
  os.chdir(gcda_directory)
  with ThreadPoolExecutor(max_workers=max_workers) as executor:
    futures = [executor.submit(run_gcov, file) for file in gcda_files]
  os.chdir(cur_dir)
  # for future in futures:
  #   file, output = future.result()
  #   print(Fore.RESET + f"Processed: {file}, output: {output}")

colors = [
  plt.cm.Purples(0.9),
  plt.cm.Blues(0.9),
  plt.cm.Greens(0.9),
  plt.cm.Oranges(0.9),
  plt.cm.Reds(0.9),
]

optional_command_suffixes = [
  '--mapping_type_prob 0.0',
  '--array_type_prob 0.0',
  '--struct_type_prob 0.0'
]

commands = [
  'npx erwin generate -m type',
  'npx erwin generate -m loc',
  'npx erwin generate -m scope',
]

def optional_command_suffix():
  # Randomly choose optional command suffixes, or return []
  return np.random.choice(optional_command_suffixes, size = np.random.randint(0, len(optional_command_suffixes)), replace = False)

def percentage(part, whole):
  Percentage = 100 * float(part)/float(whole)
  return str(Percentage) + '%'

def compile(sol_dir, mode):
  #!Step 1: Compile all Solidity programs with the instrumented compiler
  for sol_file in glob.glob(os.path.join(sol_dir, '*.sol')):
    filename = os.path.basename(sol_file)
    profraw_file = os.path.join('temp_profiles', f"{os.path.splitext(filename)[0]}.profraw")
    if mode == 'edge':
      compiler_command = f'LLVM_PROFILE_FILE="{profraw_file}" {parser_args.solc_path} {solidity_compilation_flags()} {sol_file}'
    elif mode == 'line':
      compiler_command = f'{parser_args.solc_path} {solidity_compilation_flags()} {sol_file}'
    print(Fore.GREEN + f'compiler_command: {compiler_command}')
    subprocess.run(compiler_command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def generate_solidity_edge_coverage(solc_path, sol_dir):
  """
  Generate coverage reports for multiple Solidity files.

  :param solc_path: Path to the instrumented Solidity compiler
  :param sol_dir: Directory containing Solidity files
  """
  #!Step 1: Merge all raw profile data
  # Get all .profraw files in the temp_profiles directory
  profraw_files = glob.glob('temp_profiles/*.profraw')
  # Check if any files were found
  if not profraw_files:
    print("No .profraw files found in the temp_profiles directory.")
    exit(1)
  # Construct the command
  if not os.path.exists('coverage_report') or not os.path.exists('coverage_report/solc_combined.profdata'):
    cmd = ['llvm-profdata', 'merge', '-sparse'] + profraw_files + ['-o', 'coverage_report/solc_combined.profdata']
  else:
    cmd = ['llvm-profdata', 'merge', '-sparse'] + profraw_files + ['coverage_report/solc_combined.profdata'] + ['-o', 'coverage_report/solc_combined.profdata']
  try:
    subprocess.run(cmd, check=True, capture_output=True, text=True)
  except subprocess.CalledProcessError as e:
    print(f"Error in running {cmd}: {e}")
    exit(1)
  # Get list of all Solidity files
  sol_files = glob.glob(os.path.join(sol_dir, '*.sol'))

  #!Step 2: Generate coverage reports
  # HTML report
  subprocess.run([
    'llvm-cov', 'show', solc_path, '-instr-profile=coverage_report/solc_combined.profdata',
    '-format=html', '-output-dir=coverage_report', *sol_files
  ])

  # Text summary
  with open('coverage_report/coverage_summary.txt', 'w') as f:
    subprocess.run([
      'llvm-cov', 'report', solc_path, '-instr-profile=coverage_report/solc_combined.profdata', 
      *sol_files
    ], stdout=f)

  # Detailed coverage data in JSON format
  with open('coverage_report/coverage_data.json', 'w') as f:
    subprocess.run([
      'llvm-cov', 'export', solc_path, '-instr-profile=coverage_report/solc_combined.profdata',
      '-format=text', *sol_files
    ], stdout=f)

def draw_experiment1(name, time_stamps, ax_edge, ax_line, color, g_covered_edgecnts, g_covered_linecnts):
  # Plot the coverage data of all executions
  # x is the x-axis, which is the time staps (represented in minutes)
  x = [pd.Timestamp('2023-01-01') + pd.Timedelta(seconds=t) for t in time_stamps]
  median_covered_edgecnts = np.median(g_covered_edgecnts, axis=0)
  upper_covered_edgecnts = np.max(g_covered_edgecnts, axis=0)
  lower_covered_edgecnts = np.min(g_covered_edgecnts, axis=0)
  ax_edge.plot(x, median_covered_edgecnts, label = name, color = color)
  ax_edge.fill_between(x, lower_covered_edgecnts, upper_covered_edgecnts, alpha=0.3, edgecolor=color, facecolor=color)
  # Set the x-axis to show minutes
  ax_edge.xaxis.set_major_locator(MinuteLocator(byminute=range(0, 60, 30)))  # Tick every 30 minutes
  ax_edge.xaxis.set_major_formatter(DateFormatter('%H:%M'))  # Format as HH:MM
  
  median_covered_linecnts = np.median(g_covered_linecnts, axis=0)
  upper_covered_linecnts = np.max(g_covered_linecnts, axis=0)
  lower_covered_linecnts = np.min(g_covered_linecnts, axis=0)
  ax_line.plot(x, median_covered_linecnts, label = name, color = color)
  ax_line.fill_between(x, lower_covered_linecnts, upper_covered_linecnts, alpha=0.3, edgecolor=color, facecolor=color)
  # Set the x-axis to show minutes
  ax_line.xaxis.set_major_locator(MinuteLocator(byminute=range(0, 60, 30)))  # Tick every 30 minutes
  ax_line.xaxis.set_major_formatter(DateFormatter('%H:%M'))  # Format as HH:MM
  plt.gcf().autofmt_xdate()

def store_fig_experiment1(ax_edge, ax_line, fig_edge, fig_line):
  ax_edge.set_xlabel('Time', fontsize = 25)
  ax_edge.set_ylabel('Edge Coverage', fontsize = 25)
  ax_edge.spines['right'].set_visible(False)
  ax_edge.spines['top'].set_visible(False)
  ax_edge.legend(fontsize=12)
  ax_line.set_xlabel('Time', fontsize = 25)
  ax_line.set_ylabel('Line Coverage', fontsize = 25)
  ax_line.spines['right'].set_visible(False)
  ax_line.spines['top'].set_visible(False)
  ax_line.legend(fontsize=12)
  # Save the figures
  fig_edge.savefig('coverage_report/edge_plot.pdf', format='pdf', dpi=300, bbox_inches='tight')
  fig_edge.savefig('coverage_report/edge_plot.svg', format='svg', dpi=300, bbox_inches='tight')
  fig_line.savefig('coverage_report/line_plot.pdf', format='pdf', dpi=300, bbox_inches='tight')
  fig_line.savefig('coverage_report/line_plot.svg', format='svg', dpi=300, bbox_inches='tight')

  # Optionally, close the figures to free up memory
  plt.close(fig_edge)
  plt.close(fig_line)

# Draw from log files of previous experiments
def draw_from_experiment1_data():
  fig_edge, ax_edge = plt.subplots(figsize = (8,5))
  fig_line, ax_line = plt.subplots(figsize = (8,5))
  #! collect experimental results of the trivial setting
  g_covered_edgecnts_trivial = []
  g_covered_linecnts_trivial = []
  g_edgecnt_trivial = -1
  g_linecnt_trivial = -1
  g_edgecnt_covered_trivial = -1
  g_linecnt_covered_trivial = -1
  for i in range(parser_args.executions):
    if os.path.exists(f'coverage_report/edgecov_trivial_{i}.txt'):
      with open('coverage_report/edgecov_trivial.txt', 'r') as f:
        edgecov_trivial = f.readlines()
      edgecov_trivial_ = [list(map(int, line.strip().split(','))) for line in edgecov_trivial[:-1]]
      g_covered_edgecnts_trivial = edgecov_trivial_
      g_edgecnt_trivial = edgecov_trivial[-1].split('>')[1].strip().split('/')[1]
      g_edgecnt_covered_trivial = edgecov_trivial[-1].split('>')[1].strip().split('/')[0]
    if os.path.exists(f'coverage_report/linecov_trivial{i}.txt'):
      with open('coverage_report/linecov_trivial.txt', 'r') as f:
        linecov_trivial = f.readlines()
      linecov_trivial_ = [list(map(int, line.strip().split(','))) for line in linecov_trivial[:-1]]
      g_covered_linecnts_trivial = linecov_trivial_
      g_linecnt_trivial = linecov_trivial[-1].split('>')[1].strip().split('/')[1]
      g_linecnt_covered_trivial = linecov_trivial[-1].split('>')[1].strip().split('/')[0]
  if os.path.exists('coverage_report/edgecov_trivial.txt') and os.path.exists('coverage_report/linecov_trivial.txt'):
    print(f"Trivial: Covered {percentage(g_edgecnt_covered_trivial, g_edgecnt_trivial)} edges, {percentage(g_linecnt_covered_trivial, g_linecnt_trivial)} lines")
    draw_experiment1('trivial', len(g_covered_edgecnts_trivial[0]), ax_edge, ax_line, plt.cm.Purples(0.9), g_covered_edgecnts_trivial, g_covered_linecnts_trivial)

  #! collect experimental results from the gen100 setting
  g_covered_edgecnts_gen100 = []
  g_covered_linecnts_gen100 = []
  g_edgecnt_gen100 = -1
  g_linecnt_gen100 = -1
  g_edgecnt_covered_gen100 = -1
  g_linecnt_covered_gen100 = -1
  if os.path.exists('coverage_report/edgecov_gen100.txt'):
    with open('coverage_report/edgecov_gen100.txt', 'r') as f:
      edgecov_gen100 = f.readlines()
    edgecov_gen100_ = [list(map(int, line.strip().split(','))) for line in edgecov_gen100[:-1]]
    g_covered_edgecnts_gen100 = edgecov_gen100_
    g_edgecnt_gen100 = edgecov_gen100[-1].split('>')[1].strip().split('/')[1]
    g_edgecnt_covered_gen100 = edgecov_gen100[-1].split('>')[1].strip().split('/')[0]
  if os.path.exists('coverage_report/linecov_gen100.txt'):
    with open('coverage_report/linecov_gen100.txt', 'r') as f:
      linecov_gen100 = f.readlines()
    linecov_gen100_ = [list(map(int, line.strip().split(','))) for line in linecov_gen100[:-1]]
    g_covered_linecnts_gen100 = linecov_gen100_
    g_linecnt_gen100 = linecov_gen100[-1].split('>')[1].strip().split('/')[1]
    g_linecnt_covered_gen100 = linecov_gen100[-1].split('>')[1].strip().split('/')[0]
  if os.path.exists('coverage_report/edgecov_gen100.txt') and os.path.exists('coverage_report/linecov_gen100.txt'):
    print(f"Gen100: Covered {percentage(g_edgecnt_covered_gen100, g_edgecnt_gen100)} edges, {percentage(g_linecnt_covered_gen100, g_linecnt_gen100)} lines")
    draw_experiment1('gen100', len(g_covered_edgecnts_gen100[0]), ax_edge, ax_line, plt.cm.Greens(0.9), g_covered_edgecnts_gen100, g_covered_linecnts_gen100)
  
  #! collect experimental results from the gen500 setting
  g_covered_edgecnts_gen500 = []
  g_covered_linecnts_gen500 = []
  g_edgecnt_gen500 = -1
  g_linecnt_gen500 = -1
  g_edgecnt_covered_gen500 = -1
  g_linecnt_covered_gen500 = -1
  if os.path.exists('coverage_report/edgecov_gen500.txt'):
    with open('coverage_report/edgecov_gen500.txt', 'r') as f:
      edgecov_gen500 = f.readlines()
    edgecov_gen500_ = [list(map(int, line.strip().split(','))) for line in edgecov_gen500[:-1]]
    g_covered_edgecnts_gen500 = edgecov_gen500_
    g_edgecnt_gen500 = edgecov_gen500[-1].split('>')[1].strip().split('/')[1]
    g_edgecnt_covered_gen500 = edgecov_gen500[-1].split('>')[1].strip().split('/')[0]
  if os.path.exists('coverage_report/linecov_gen500.txt'):
    with open('coverage_report/linecov_gen500.txt', 'r') as f:
      linecov_gen500 = f.readlines()
    linecov_gen500_ = [list(map(int, line.strip().split(','))) for line in linecov_gen500[:-1]]
    g_covered_linecnts_gen500 = linecov_gen500_
    g_linecnt_gen500 = linecov_gen500[-1].split('>')[1].strip().split('/')[1]
    g_linecnt_covered_gen500 = linecov_gen500[-1].split('>')[1].strip().split('/')[0]
  if os.path.exists('coverage_report/edgecov_gen500.txt') and os.path.exists('coverage_report/linecov_gen500.txt'):
    print(f"Gen500: Covered {percentage(g_edgecnt_covered_gen500, g_edgecnt_gen500)} edges, {percentage(g_linecnt_covered_gen500, g_linecnt_gen500)} lines")
    draw_experiment1('gen500', len(g_covered_edgecnts_gen500[0]), ax_edge, ax_line, plt.cm.Blues(0.9), g_covered_edgecnts_gen500, g_covered_linecnts_gen500)
    
  #! collect experimental results from the gen1000 setting
  g_covered_edgecnts_gen1000 = []
  g_covered_linecnts_gen1000 = []
  g_edgecnt_gen1000 = -1
  g_linecnt_gen1000 = -1
  g_edgecnt_covered_gen1000 = -1
  g_linecnt_covered_gen1000 = -1
  if os.path.exists('coverage_report/edgecov_gen1000.txt'):
    with open('coverage_report/edgecov_gen1000.txt', 'r') as f:
      edgecov_gen1000 = f.readlines()
    edgecov_gen1000_ = [list(map(int, line.strip().split(','))) for line in edgecov_gen1000[:-1]]
    g_covered_edgecnts_gen1000 = edgecov_gen1000_
    g_edgecnt_gen1000 = edgecov_gen1000[-1].split('>')[1].strip().split('/')[1]
    g_edgecnt_covered_gen1000 = edgecov_gen1000[-1].split('>')[1].strip().split('/')[0]
  if os.path.exists('coverage_report/linecov_gen1000.txt'):
    with open('coverage_report/linecov_gen1000.txt', 'r') as f:
      linecov_gen1000 = f.readlines()
    linecov_gen1000_ = [list(map(int, line.strip().split(','))) for line in linecov_gen1000[:-1]]
    g_covered_linecnts_gen1000 = linecov_gen1000_
    g_linecnt_gen1000 = linecov_gen1000[-1].split('>')[1].strip().split('/')[1]
    g_linecnt_covered_gen1000 = linecov_gen1000[-1].split('>')[1].strip().split('/')[0]
  if os.path.exists('coverage_report/edgecov_gen1000.txt') and os.path.exists('coverage_report/linecov_gen1000.txt'):
    print(f"Gen1000: Covered {percentage(g_edgecnt_covered_gen1000, g_edgecnt_gen1000)} edges, {percentage(g_linecnt_covered_gen1000, g_linecnt_gen1000)} lines")
    draw_experiment1('gen1000', len(g_covered_edgecnts_gen1000[0]), ax_edge, ax_line, plt.cm.Reds(0.9), g_covered_edgecnts_gen1000, g_covered_linecnts_gen1000)
  
  store_fig_experiment1(ax_edge, ax_line, fig_edge, fig_line)

def run_experiment1_line(name, executions, time_limit, command_prefix, command_suffix, solc_path, generated_programs_folder_path, gcov_folder_path):
  if not os.path.exists('coverage_report'):
    os.makedirs('coverage_report')
  for i in range(executions):
    remove_gcda_files(gcov_folder_path)
    time_budget = time_limit
    fline = open(f'./coverage_report/linecov_{name}_{i}.txt', 'w')
    g_covered_line = set()
    while time_budget > 0:
      remove_gcov_files(gcov_folder_path)
      command = f'{np.random.choice(commands) if command_prefix=="" else command_prefix} {command_suffix} {" ".join(optional_command_suffix())}'
      print(Fore.CYAN + f"Erwin command: {command}")
      gen_start = time.time()
      try:
        p = subprocess.run(command, shell=True, capture_output=True, text=True)
      except Exception as e:
        print(f"Error: {e}\n{p.stderr}\n{p.stdout}")
        continue
      gen_end = time.time()
      print(Fore.CYAN + f"Erwin execution: {gen_end-gen_start} seconds")
      if not os.path.exists(generated_programs_folder_path) or len(os.listdir(generated_programs_folder_path)) == 0:
        continue
      start = time.time()
      compile(generated_programs_folder_path, 'line')
      end = time.time()
      print(Fore.MAGENTA + f"compile: {end-start} seconds")
      covered_line, line = extract_collected_lines(gcov_folder_path)
      g_covered_line = covered_line
      covered_linecnt = len(covered_line)
      linecnt = len(line)
      time_budget -= gen_end-gen_start
      print(Fore.BLUE + f"> Execution {i+1}, Time Cost: {gen_end-gen_start} seconds, Time Budget: {time_budget} seconds, {covered_linecnt}/{linecnt} lines covered")
      fline.write(f'{time_limit - time_budget}: {covered_linecnt}/{linecnt}\n')
      fline.flush()
    with open(f'./coverage_report/linecovmap_{name}_{i}.txt', 'a') as f:
      for line in g_covered_line:
        f.write(f"{line.filename}:{line.linenum}\n")
    fline.close()

def run_experiment1_edge(name, executions, time_limit, command_prefix, command_suffix, solc_path, generated_programs_folder_path, gcov_folder_path):
  if not os.path.exists('coverage_report'):
    os.makedirs('coverage_report')
  for i in range(executions):
    time_budget = time_limit
    fedge = open(f'./coverage_report/edgecov_{name}_{i}.txt', 'w')
    if os.path.exists(f'./coverage_report/solc_combined.profdata'):
      os.remove(f'./coverage_report/solc_combined.profdata')
    while time_budget > 0:
      if os.path.exists('temp_profiles'):
        for file in glob.glob('temp_profiles/*'):
          os.remove(file)
        os.rmdir('temp_profiles')
      os.makedirs('temp_profiles')
      command = f'{np.random.choice(commands) if command_prefix=="" else command_prefix} {command_suffix} {" ".join(optional_command_suffix())}'
      print(Fore.CYAN + f"Erwin command: {command}")
      gen_start = time.time()
      try:
        p = subprocess.run(command, shell=True, capture_output=True, text=True)
      except Exception as e:
        print(f"Error: {e}\n{p.stderr}\n{p.stdout}")
        continue
      gen_end = time.time()
      print(Fore.CYAN + f"Erwin execution: {gen_end-gen_start} seconds")
      if not os.path.exists(generated_programs_folder_path) or len(os.listdir(generated_programs_folder_path)) == 0:
        continue
      start = time.time()
      compile(generated_programs_folder_path, 'edge')
      end = time.time()
      if not os.path.exists('temp_profiles'):
        continue
      print(Fore.MAGENTA + f"compile: {end-start} seconds")
      start = time.time()
      # Compile the generated programs and generate coverage json file
      generate_solidity_edge_coverage(solc_path, generated_programs_folder_path)
      end = time.time()
      print(Fore.MAGENTA + f"generate_solidity_edge_coverage: {end-start} seconds")
      # Collect llvm-cov coverage data
      with open('./coverage_report/coverage_data.json', 'r') as f:
        coverage_data = json.load(f)
      start = time.time()
      collected_edges = extract_collected_edges(coverage_data)
      end = time.time()
      print(Fore.MAGENTA + f"extract_collected_edges: {end-start} seconds")
      edgecnt = 0
      covered_edgecnt = 0
      for edge in collected_edges:
        edgecnt += 1
        if collected_edges[edge] > 0:
          covered_edgecnt += 1
      time_budget -= gen_end-gen_start
      print(Fore.BLUE + f"> Execution {i+1}, Time Cost: {gen_end-gen_start} seconds, Time Budget: {time_budget} seconds, {covered_edgecnt}/{edgecnt} edges covered")
      fedge.write(f'{time_limit - time_budget}: {covered_edgecnt}/{edgecnt}\n')
      fedge.flush()
    fedge.close()
  # reset the color
  # Clean up intermediate profraw files
  for file in glob.glob('temp_profiles/*'):
    os.remove(file)
  os.rmdir('temp_profiles')

def run_experiment1(name, executions, time_limit, command_prefix, command_suffix, solc_path, generated_programs_folder_path, gcov_folder_path):
  if parser_args.line:
    run_experiment1_line(name, executions, time_limit, command_prefix, command_suffix, solc_path, generated_programs_folder_path, gcov_folder_path)
  
  if parser_args.edge:
    run_experiment1_edge(name, executions, time_limit, command_prefix, command_suffix, solc_path, generated_programs_folder_path, gcov_folder_path)

'''
Experiment 1.
Compare edge/line coverage increase speed over different generation setting.
'''
def experiment1():
  
  collect_solidity_sources(parser_args.compiler_source_folder_path)
  
  command_suffix = f'--generation_rounds 1 --refresh_folder'
  
  if (parser_args.setting == 'trivial'):
    print('Setting 1: Trivial generation')
    run_experiment1('trivial', parser_args.executions, parser_args.time_limit, 'npx erwin generate', command_suffix, parser_args.solc_path, parser_args.generated_programs_folder_path, parser_args.gcov_folder_path)
  elif (parser_args.setting == 'gen100'):
    print('Setting 2: Generate at most 50 programs from an IR')
    run_experiment1('gen100', parser_args.executions, parser_args.time_limit, '', f'--max 100 {command_suffix}', parser_args.solc_path, parser_args.generated_programs_folder_path, parser_args.gcov_folder_path)
  elif (parser_args.setting == 'gen500'):
    print('Setting 3: Generate at most 100 programs from an IR')
    run_experiment1('gen500', parser_args.executions, parser_args.time_limit, '', f'--max 500 {command_suffix}', parser_args.solc_path, parser_args.generated_programs_folder_path, parser_args.gcov_folder_path)
  elif (parser_args.setting == 'gen1000'):
    print('Setting 4: Generate at most 1000 programs from an IR')
    run_experiment1('gen1000', parser_args.executions, parser_args.time_limit, '', f'--max 1000 {command_suffix}', parser_args.solc_path, parser_args.generated_programs_folder_path, parser_args.gcov_folder_path)

'''
Experiment 2.
Compare edge/line coverages between Erwin-generated test programs and Solidity compiler unit test cases.
'''
def experiment2(collected_edges1, collected_edges2):
  coverage_json_path1 = input("Enter the path to the first coverage JSON file: ")
  coverage_json_path2 = input("Enter the path to the second coverage JSON file: ")

  # Example usage
  with open(coverage_json_path1, 'r') as f:
    coverage_data = json.load(f)

  collected_edges1 = extract_collected_edges(coverage_data)

  with open(coverage_json_path2, 'r') as f:
    coverage_data = json.load(f)

  collected_edges2 = extract_collected_edges(coverage_data)

  # Print the collected edges
  for edge in collected_edges1:
    assert edge in collected_edges2
    if (collected_edges1[edge] > 0) != (collected_edges2[edge] > 0):
      print(f"Edge {edge} has different counts: {collected_edges1[edge]} vs {collected_edges2[edge]}")

'''
Experiment 3.
Compare line coverage increase speed over different generation setting.
'''
def experiment3(gcovfolder1, gcovfolder2):
  collected_lines1 = extract_collected_lines(gcovfolder1)
  collected_lines2 = extract_collected_lines(gcovfolder2)
  # Output the number of lines covered by collected_lines1 but not collected_lines2
  print(f'collected_lines1 - collected_lines2 = {len(collected_lines1 - collected_lines2)}')
  # Output the number of lines covered by collected_lines2 but not collected_lines1
  print(f'collected_lines2 - collected_lines1 = {len(collected_lines2 - collected_lines1)}')
  # Output the number of lines covered by both collected_lines1 and collected_lines2
  print(f'collected_lines1 & collected_lines2 = {len(collected_lines1 & collected_lines2)}')
  # Output the first ten elements in collected_lines1
  print(f'collected_lines1: {list(collected_lines1)[:10]}')
  # Output the first ten elements in collected_lines2
  print(f'collected_lines2: {list(collected_lines2)[:10]}')
  venn2([collected_lines1, collected_lines2], ('1', '2'))
  plt.show()
  

solc_path = '/data/hmaaj/solidity/build-experiment1/solc/solc'
generated_programs_folder_path = '/data/hmaaj/Erwin/generated_programs'
gcov_folder_path = '/data/hmaaj/solidity/build-experiment1'
compiler_source_folder_path = '/data/hmaaj/solidity'

solc_path = '/Users/mac/repo/solidity/build-lcov/solc/solc'
generated_programs_folder_path = '/Users/mac/repo/Erwin/generated_programs'
gcov_folder_path = '/Users/mac/repo/solidity/build-lcov'
compiler_source_folder_path = '/Users/mac/repo/solidity'

if __name__ == '__main__':
  parser = argparse.ArgumentParser(
                    prog='coverage',
                    description='Collect coverage data from Solidity compilers and draw coverage plots')
  subparsers = parser.add_subparsers(dest='experiment', help='Experiment-specific arguments')
  parser_exp1 = subparsers.add_parser('experiment1', help='Arguments for Experiment 1')
  parser_exp1.add_argument('--setting', type=str, help='Generation setting', choices=['trivial', 'gen100', 'gen500', 'gen1000'], default='trivial')
  parser_exp1.add_argument('--executions', type=int, help='Number of executions of this experiment', default=3)
  parser_exp1.add_argument('--time_limit', type=float, help='Time limit for each executions, in seconds', default=3600*4)
  parser_exp1.add_argument('--solc_path', type=str, help='Path to the instrumented Solidity compiler', default=solc_path)
  parser_exp1.add_argument('--generated_programs_folder_path', type=str, help='Path to the generated programs folder', default=generated_programs_folder_path)
  parser_exp1.add_argument('--gcov_folder_path', type=str, help='Path to the gcov folder', default=gcov_folder_path)
  parser_exp1.add_argument('--compiler_source_folder_path', type=str, help='Path to the compiler source folder', default=compiler_source_folder_path)
  parser_exp1.add_argument('--line', action='store_true', help='Collect line coverage data')
  parser_exp1.add_argument('--edge', action='store_true', help='Collect edge coverage data')

  parser_args = parser.parse_args()

  if parser_args.experiment == 'experiment1':
    if not parser_args.edge and not parser_args.line:
      print('Please specify at least one type of coverage data to collect (edge or line)')
      exit(1)
    experiment1()
